#include <IRremote.h>  // import infrared remote library
#include <LiquidCrystal.h> // import library for LCD keypad shield

// define pins for dc motor connection
const int leftMotor_forward = 9;
const int leftMotor_backward = 10;
const int rightMotor_forward = 11;
const int rightMotor_backward = 12;

//define pins for LED connection
const int LED1 = 1;
const int LED2 = 3;
const int LED3 = 4;
const int LED4 = 5;
const int LED5 = 6;
const int LED6 = 13;

// define pins for ultrasonic sensor connection
const int triggerPin = 7;
const int echoPin = 8;

// define long integers to store values for the time and distance (using time, we multiply by the constant rate of 0.343 m/s to get the distance)
long duration, distance;

// define pin for remote control
const int IRsensorPin = 2;

// this is needed in a for loop later to automatically stop the brake lights
int i;

// create an instance for the receiving signal and create an instance to store the collected data
IRrecv irrecv(IRsensorPin);
decode_results results;

// initialize
void setup() {
  // Set the LCD shield pins
  LiquidCrystal lcd(8, 9, 4, 5, 6, 7);
  lcd.begin(16, 2); // start the 16 x 2 (has two rows each with 16 characters) LCD display
  lcd.setCursor(0, 0); // set cursor to top left of screen
  lcd.print("Tesla Cybertruck"); // appears on top row
  lcd.setCursor(0, 1); // move cursor to second row (bottom left)

  // set LEDs as output
  pinMode(LED1, OUTPUT);
  pinMode(LED2, OUTPUT);
  pinMode(LED3, OUTPUT);
  pinMode(LED4, OUTPUT);
  pinMode(LED5, OUTPUT);
  pinMode(LED6, OUTPUT);

  // set trigger pin as output (to emit waves) and echo pin as input (to receive waves) for ultrasonic sensor
  pinMode(triggerPin, OUTPUT);
  pinMode(echoPin, INPUT);

  // set DC motor pins to output
  
  delay(5);
  lcd.print("Manual Mode"); // manual mode is a mode in which the cybertruck is controlled by pressing keys on a remote (Xfinity remote is being used here)
  irrecv.resume(); // continue detecting IR signals

  }

void loop() {

  // this code gives instructions to the cybertruck on what to do if a specific key is pressed (using hexadecimal values) in manual mode
  if (results.value == 0000) forward(); // if the up key is pressed on the remote, move forward
  if (results.value == 0000) backward(); // if down key pressed on remote, move backward
  if (results.value == 0000) turnLeft(); // if left key pressed on remote, turn left
  if (results.value == 0000) turnRight(); // if right key pressed on remote, turn right
  if (results.value == 0000) Stop(); // if "OK" key pressed on remote, stop
  if (results.value == 0000) zigZag(); // if "2" key pressed on remote, zig-zag forwards (zig zagging backwards not a feature since this can result in safety issues and discomfort for passengers)
  if (results.value == 0000) turnOnHeadLights; // if "Xfinity" key pressed on remote, turn on the head lights
  if (results.value == 0000) turnOffHeadLights; // if "1" key pressed on remote, turn off head lights
  if (results.value == 0000) allBlink(); // if "Mute" key pressed on remote, make all LEDs blink
  if (results.value == 0000) allStopBlink(); // if "7" key pressed on remote, turn off all LEDs
  if (results.value == 0000) autoPilot(); // if "0" key pressed on remote, go on auto pilot mode. Autopilot mode is a special mode in which the robot moves by itself (more detailed explanation in autoPilot method down below)
  if (results.value == 0000) autoPilot(); // if "8" key pressed on remote, go on auto pilot mode.



  // this activates the triggerPin
  digitalWrite(triggerPin, LOW);
  delayMicroseconds(1);
  digitalWrite(triggerPin, HIGH);
  delayMicroseconds(1);
  digitalWrite(triggerPin, LOW);

  // the time it takes for the waves to return back to the sensor is determined using the echoPin which takes input
  duration = pulseIn(echoPin, HIGH);

  // using the time taken, multiply that with a constant rate of 0.034 (rate of ultrasonic waves at m/s) and divide it by 2 (the waves also return back to the sensor, so not dividing by 2 would cause double counting distance)
  distance = (duration * 0.034) / 2;

}

// THESE NEXT 5 METHODS DEFINED CONTROL THE MOVEMENT OF THE MOTOR USING THE L293D DRIVER CHIP

// this method defines how the robot moves forward by activating both motors and telling them to move forward
void forward() {
  digitalWrite(leftMotor_forward, HIGH);
  digitalWrite(leftMotor_backward, LOW);
  digitalWrite(rightMotor_forward, HIGH);
  digitalWrite(rightMotor_backward, LOW);
  lcd.print("It's moving forward"); // this message appears on the display that is attached to the robot car
  delay(1000);

}

// this method defines how the robot moves backward by activating both motors and telling them to move backwards
void backward() {
  digitalWrite(leftMotor_forward, LOW);
  digitalWrite(leftMotor_backward, HIGH);
  digitalWrite(rightMotor_forward, LOW);
  digitalWrite(rightMotor_backward, HIGH);
  lcd.println("It's moving backward"); // this message appears on the display that is attached to the robot car
  delay(1000);
}

// this method defines how the robot turns left by making the right motor move forward, and the left motor move backward
void turnLeft() {
  digitalWrite(leftMotor_forward, LOW);
  digitalWrite(leftMotor_backward, HIGH);
  digitalWrite(rightMotor_forward, HIGH);
  digitalWrite(rightMotor_backward, LOW);
  Blink3(); // this method is defined later and this method basically makes the left side mirror light blink to signal that the car is turning left
  lcd.print("It's turning left"); // this message appears on the display that is attached to the robot car
}

// this method defines how the robot turns right by making the left motor move forward, and the right motor move backward
void turnRight() {
  digitalWrite(leftMotor_forward, HIGH);
  digitalWrite(leftMotor_backward, LOW);
  digitalWrite(rightMotor_forward, LOW);
  digitalWrite(rightMotor_backward, HIGH);
  Blink4(); // like Blink3(), this method is defined later and it makes the right side mirror light blink to signal that the car is moving right
  lcd.print("It's turning right"); // this message appears on the display that is attached to the robot car
}

// this method defines how the robot stops by deactivating both motors
void Stop() {
  digitalWrite(leftMotor_forward, LOW);
  digitalWrite(leftMotor_backward, LOW);
  digitalWrite(rightMotor_forward, LOW);
  digitalWrite(rightMotor_backward, LOW);
  brakeLights(); // this method is defined later, but it turns on the brake lights when the car is stopping (more information explained later)
  lcd.print("It has stopped"); // this message appears on the display that is attached to the robot car
}

// this method makes all the LEDs on the car blink
void allBlink() {
  lcd.print("All blinking");
  Blink1();
  Blink2();
  Blink3();
  Blink4();
  Blink5();
  Blink6();
}

// this method stops the LEDs from blinking
void allStopBlink() {
  if (LED1 == HIGH || LED2 == HIGH || LED3 == HIGH || LED4 == HIGH || LED5 == HIGH || LED6 == HIGH) {
    digitalWrite(1, LOW);
    delay(1000);
    digitalWrite(3, LOW);
    delay(1000);
    digitalWrite(4, LOW);
    delay(1000);
    digitalWrite(5, LOW);
    delay(1000);
    digitalWrite(6, LOW);
    delay(1000);
    digitalWrite(13, LOW);
    delay(1000);
  }
}

// this will make the head light blink
void Blink1() {
  digitalWrite(1, HIGH);
  delay(1000);
  digitalWrite(1, LOW);
  delay(1000);
  lcd.print("Headlights blinking");
}

// this will make the second head light blink
void Blink2() {
  digitalWrite(3, HIGH);
  delay(1000);
  digitalWrite(3, LOW);
  delay(1000);
  lcd.print("Headlights blinking");
}

// this will make the sidelights blink (next method does the same thing)
void Blink3() {
  digitalWrite(4, HIGH);
  delay(1000);
  digitalWrite(4, LOW);
  delay(1000);
  lcd.print("Sides blinking");
}

void Blink4() {
  digitalWrite(5, HIGH);
  delay(1000);
  digitalWrite(5, LOW);
  delay(1000);
  lcd.print("Sides blinking");
}

// the next method makes the rear light blink
void Blink5() {
  digitalWrite(6, HIGH);
  delay(1000);
  digitalWrite(6, LOW);
  delay(1000);
  lcd.print("Rear blinking");
}

// this method makes the brake light blink
void Blink6() {
  digitalWrite(13, HIGH);
  delay(1000);
  digitalWrite(13, LOW);
  delay(1000);
  lcd.print("Brakes blinking");
}

// this turns on the headlights (this, and the next 3 methods are used on manual mode)
void turnOnHeadLights() {
  digitalWrite(1, HIGH);
  delay(1000);
  digitalWrite(3, HIGH);
  delay(1000);
  lcd.print("Headlights on");
}

void turnOffHeadLights() {
  digitalWrite(1, LOW);
  delay(1000);
  digitalWrite(3, LOW);
  delay(1000);
  lcd.print("Headlights off");
}

// this method activates the side lights
void turnOnSideLights() {
  digitalWrite(4, HIGH);
  delay(1000);
  digitalWrite(5, HIGH);
  delay(1000);
  lcd.print("Side lights on");
}

void turnOffSideLights() {
  digitalWrite(4, LOW);
  delay(1000);
  digitalWrite(5, LOW);
  delay(1000);
  lcd.print("Side lights off");
}

// this method turns on the rear lights
void turnOnBackLights() {
  digitalWrite(6, HIGH);
  delay(1000);
  lcd.print("Rear lights on");
}

void turnOffBackLights() {
  digitalWrite(6, LOW);
  delay(1000);
  lcd.print("Rear lights off");
}

// this method turns on the brake lights when the robot car stops. The stopBrakeLights() method is called to automatically stop the brake lights (if they aren't already) after the car has stopped for 3 seconds
void brakeLights() {
  digitalWrite(13, HIGH);
  delay(1000);
  lcd.print("Brake Lights On");
  // this is a called method to stop the brake lights and is defined in the next method
  stopBrakeLights();
}

void stopBrakeLights() {
  for (i = 0; i < 3; i++) {
    delay(i * 1000);
  }
  digitalWrite(LED6, LOW);
  delay(1000);
}

// this method makes the car zig-zag
void zigZag() {
  int zigZagSteps[] = {1, 2};
  for (int steps : zigZagSteps) {
    turnRight();
    Blink3(); // blinking signals to other cars that this car is turning left
    allStopBlink();
    turnLeft();
    Blink4(); // does the same task as Blink3() except does it for signaling turning right
  }
  lcd.print("It's zig-zagging");
}

// this is the autopilot method which the robot car completely moves by itself. It will always move forward until it senses an object that is too close. If an object is too close, then it will avoid it by backing up and turning left.
void autoPilot() {
  forward();

  if (distance < 18) {
    Stop();
    backward();
    Stop();
    turnLeft();
    lcd.print("Too close!");
  }
  lcd.print("Autopilot mode");
}
